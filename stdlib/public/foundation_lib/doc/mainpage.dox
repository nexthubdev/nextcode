/*!
\mainpage Overview

\subpage build_page
<br><br>
\subpage test_page
<br><br>
\subpage tools_page
<br><br>
\subpage overview_page
<br><br>
\subpage features_page
<br><br>
\subpage using_page
<br><br>


\page build_page Building the library
\tableofcontents
\section overview Overview

\subsection configs Configurations
The library can be built in four different build configurations with increasing amount of optimizations
and decreasing amount of debug possibilities. The configurations are named debug, release, profile and deploy
with the deploy configuration the recommended configuration for releases to the public.

\subsubsection debug Debug
In debug configuration no optimizations are enabled and all debug functionality is available in the library, including
asserts, logging and error handling. This configuration is intented for development purposes.

\subsubsection release Release
In release configuration most optimizations are enabled and all debug functionality is available in the library, including
asserts, logging and error handling. This configuration is intented for testing purposes.

\subsubsection profile Profile
In profile configuration all optimizations are enabled and all debug functionality is disabled in the library, including
asserts, logging and error handling. Profiling hooks and measurements are included in the library code. This configuration
is intented for profiling purposes, as it is identical to the final deploy build except for profiling code being enabled.

\subsubsection deploy Deploy
In deploy configuration all optimizations are enabled and all debug functionality is disabled in the library, including
asserts, logging and error handling. Profiling is also disabled. This configuration is intented for public releases.

\subsection output Output
Libraries will be placed in lib/[platform]/[configuration]/[architecture] with platform names
<ul>
<li>windows</li>
<li>linux</li>
<li>macos</li>
<li>ios</li>
<li>android</li>
<li>bsd</li>
<li>raspberrypi</li>
</ul>
Configuration names are
<ul>
<li>debug</li>
<li>release</li>
<li>profile</li>
<li>deploy</li>
</ul>
Architecture names are
<ul>
<li>arm6</li>
<li>arm7</li>
<li>arm64</li>
<li>x86</li>
<li>x86-64</li>
<li>mips</li>
<li>mips64</li>
</ul>

For macOS and iOS builds the libraries and binaries/apps will be universal and placed directly in the corresponding configuration directory and not in separate directories per architecture. For Android apps will be universal (containing the native variants used) and placed directly in the corresponding configuration directory.

Test cases are built as separate binaries with a launcher binary, placed in bin/[platform]/[configuration]/[architecture] (or directly in the configuration directory for macOS and iOS since the binaries are universal).

\section ninja Ninja
Building with Ninja is almost identical across all supported platforms. Use the build configuration python script in the root directory to set the architectures and build configurations you want, along with any configuration options.

\subsection ninja_configurations Configurations
Any combination of configurations can be built in one build. Specify which configurations to build with the -c switch. For example, to build all configurations use <code>-c debug -c release -c profile -c deploy</code>.

\subsection ninja_arch Architectures
Any combination of architectures supported by the host, target and toolchain combination can be built in one build. By default (if no other directive is given) all architectures
supported will be built. Specify which architectures to build with the -a switch. For example, to build all architectures in an Android build use
<code>-a arm6 -a arm7 -a arm64 -a mips -a mips64 -a x86 -a x86-64</code>

\subsection ninja_toolchain Toolchains
There is currently support for four different toolchains depending on your host platform. These are CLang, Microsoft, GCC and Intel. Not all toolchains are supported on all host platforms. Specify which toolchain to use with the <code>--toolchain</code> switch. For example, to use gcc when building for Android use <code>--toolchain gcc</code>. The toolchain names are
<ul>
<li>clang</li>
<li>msvc</li>
<li>gcc</li>
<li>intel</li>
</ul>

\subsection ninja_target Targets
By using the target switch (-t) you can cross-compile to a secondary target platform. Currently you can cross compile for iOS on macOS, and for Android on Windows, Linux and macOS.

Use the <code>-t ios</code> target switch to specify iOS builds. By default arm7 and arm64 architectures will be built (universal).

Use the <code>-t android</code> target switch to specify Android builds. By default all architectures supported by your Android SDK/NDK will be built.
For arm6 (armeabi) the library is built in ARM instruction mode (not THUMB). For arm7 (armeabi-v7a) the library is built in ARM instruction mode (not THUMB) and has NEON enabled.

\subsection ninja_host Host specifics
If you use SublimeText there is a template SublimeText project with a Ninja build tool setup in <code>build/foundation.sublime-project</code>.
The build requires you to have generated a ninja build with the configure.py python script.

On Windows the default toolchain is the Microsoft compiler suite. You should run the appropriate <code>vcvarsall.bat</code>
environment setup batch script for the architecture you choose prior to starting builds
(or use the preconfigured command prompts from Visual Studio installs).

On macOS (and when cross compiling for iOS) the default toolchain is clang. The only supported architecture is x86-64 targetting macOS 10.7 or later,
and arm7/arm64 targeting iOS 8.0 or later. The ninja will use the latest SDK and clang toolchain available by using the xcrun tool to locate SDK and binary paths.

On Linux the default toolchain is clang. The supported architectures are x86, x86-64, arm6, arm7, arm64, mips and mips64.

Building for Android requires NDK r11 or later. The default toolchain is clang.

On Raspberry Pi the default toolchain is gcc. The only supported architecture is arm6 (with Raspberry Pi specific compiler switches).

\subsection ninja_codesign Code signing
The Ninja build will by default sign the Android apk and iOS app bundles it builds. The signatures, keystores and passwords used in this process can be specified
through the build options. On Android the default settings is to use the normal Android SDK debug keystore to autosign the apk.

\subsection options Build options
Some build variables can be set externally from the ninja build files. These variables are
<ul>
<li>android: ndkpath - Path to the Android NDK (no default)</li>
<li>android: sdkpath - Path to the Android SDK (no default)</li>
<li>android: platformversion - Android platform version to use when building (default "21")</li>
<li>android: gccversion - GCC toolchain version to use when building (default "4.9")</li>
<li>ios: deploymenttarget - Minimum iOS target version (default "8.0")</li>
<li>macos: deploymenttarget - Minimum MacOS X target version (default "10.7")</li>
<li>msvc: toolchain - Path to Visual Studio toolchain to use (default value is autodetected)</li>
<li>msvc: sdkpath - Path to Windows SDK to use (default value is autodetected)</li>
<li>tizen: sdkpath - Path to the Tizen SDK (no default)</li>
<li>tizen: platformversion - Version of the Tizen platform to use (default "2.3")</li>
<li>tizen: gccversion - GCC toolchain version to use when building (default "4.8")</li>
<li>tizen: clangversion - CLang toolchain version to use when building (default "3.4")</li>
</ul>

The bundle identifier variables can contain expansion variables which will be substituted during build. These include
<ul>
<li>\$(binname) - Binary name (for example, "test-all")</li>
</ul>

The variables can be set in four different ways, in increasing order of priority.
<ul>
<li>configure.py script variables passed to generator</li>
<li>build.json file in root project directory, read during configure.py execution</li>
<li>codesign.json file in root project directory, read at build time</li>
</ul>

Passing variables to the generator in configure.py is a simple list of key-value pairs. For example <code>variables = [ ( 'bundleidentifier', 'com.maniccoder.foundation.\$(binname)' ) ]</code>.
Any variables that have a identical name with different platform prefix can be passed without any platform name as in the example. The value will be applied to all platform specific variables.

The build.json is a simple host-local file which can hold any variable values listed. The value should be put in enclosing groups for each platforms (see example). The values will be set after parsing the configure.py variables. An example build.json file:
<pre>{
	"android" : {
		"ndkpath" : "~/android-ndk",
		"sdkpath" : "~/android-sdk",
		"platformversion" : "21",
		"gccversion" : "4.9",
	},
	"ios" : {
		"deploymenttarget" : "8.0"
	},
	"macos" : {
		"deploymenttarget" : "10.7"
	}
    "msvc" : {
        "toolchain" : "C:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin"
    }
}</pre>

Finally, the codesign.json is read by the codesigning phase at build time and can hold the secrets related to code signing. This allows you to have the secret locally on the build machine without requiring recreation of the build scripts or storing secrets in version control. The format is the same as for build.json and the variables used are:
<ul>
<li>android: keystore</li>
<li>android: keyalias</li>
<li>android: keystorepass</li>
<li>android: keypass</li>
<li>android: tsa</li>
<li>android: tsacert</li>
<li>ios: organisation</li>
<li>ios: bundleidentifier</li>
<li>ios: signature</li>
<li>ios: provisioning</li>
<li>macos: organisation</li>
<li>macos: bundleidentifier</li>
<li>macos: signature</li>
</ul>

An example codesign.json file:
<pre>{
    "android" : {
        "keystore" : "~/.android/debug.keystore",
        "keyalias" : "androiddebugkey",
        "keystorepass" : "android",
        "keypass" : "android"
    },
    "ios" : {
        "organisation" : "TXXXYZ12AB",
        "bundleidentifier" : "com.mycompany.\$(binname)",
        "signature" : "ABCDEF0123456789ABCDEF0123456789ABCDEF01",
        "provisioning" : "01234567-89AB-CDEF-0123-456789ABCDEF.mobileprovision"
    },
    "macos" : {
        "organisation" : "TXXXYZ12AB",
        "bundleidentifier" : "com.mycompany.$(binname)",
        "signature" : "ABCDEF0123456789ABCDEF0123456789ABCDEF01"
    }
}</pre>

\section visual_studio Visual Studio
On Windows we currently support building with Microsoft and Intel compilers with Visual Studio 2017. Both 32-bit and 64-bit Windows are supported.
To build with Visual Studio, open the foundation.sln solution file Visual Studio 2017 in <code>build/vs17</code>. To build all targets and configurations
use batch build, select all targets and build.

\section xcode XCode
To build with XCode, open the XCode workspace in <code>build/xcode/foundation-osx.xcworkspace</code> for macOS and
<code>build/xcode/foundation-ios.xcworkspace</code> for iOS and build the appropriate targets.
The workspace contains projects for both foundation library and test cases. The only supported architecture is x86-64 targetting macOS 10.7 or later,
or for iOS arm7/arm64 targeting iOS 8.0 or later.

\section external External
For integration with other build systems, here is a list of the compiler/linker flags used during compilation and linking of the foundation library, test apps and tools.

\subsection flags_generic Generic flags
During compilation of the library itself, <code>FOUNDATION_COMPILE</code> should be defined to non-zero. This must not be defined when compiling projects that use the library.

Depending on the build configuration wanted, the appropriate build configuration symbol should be defined to non-zero.
<ul>
<li><code>BUILD_DEBUG</code></li>
<li><code>BUILD_RELEASE</code></li>
<li><code>BUILD_PROFILE</code></li>
<li><code>BUILD_DEPLOY</code></li>
</ul>

All other build control directives are defined in the build.h header.

\subsection flags_clang CLang flags
- Include/build: <code>-I. -Itest -DFOUNDATION_COMPILE=1 -DBUILD_<DEBUG|RELEASE|PROFILE|DEPLOY>=1</code>
- Warning: <code>-W -Weverything -Werror</code>
- All builds: <code>-funit-at-a-time -fstrict-aliasing -fno-math-errno -ffinite-math-only -funsafe-math-optimizations -fno-trapping-math -ffast-math -g</code>
- Debug: <code>-O0</code>
- Release: <code>-funroll-loops -O3</code>
- Profile/deploy: <code>-funroll-loops -O3</code>

All platforms use <code>-std=c11</code> to define using the C11 standard.

\subsection flags_gcc GCC flags
- Include/build: <code>-I. -Itest -DFOUNDATION_COMPILE=1 -DBUILD_<DEBUG|RELEASE|PROFILE|DEPLOY>=1</code>
- Warning: <code>-W -Wall -Werror</code>
- All builds: <code>-funit-at-a-time -fstrict-aliasing -fno-math-errno -ffinite-math-only -funsafe-math-optimizations -fno-trapping-math -ffast-math -g</code>
- Debug: <code>-O0</code>
- Release: <code>-funroll-loops -O3</code>
- Profile/deploy: <code>-funroll-loops -O4</code>

Most platforms use <code>-std=c11</code> to define using the C11 standard. The exceptions for this is Android which uses <code>-std=gnu11</code> to work around issues in the NDK includes, and Raspberry Pi which uses <code>-std=c99</code> due to lack of compiler support at the time. Raspberry Pi builds also use <code>-fno-omit-frame-pointer</code> to make the stack walker work using frame pointers.

Apart from this you should specify the appropriate machine flags for the architecture you are compiling for, like <code>-m64</code> for x86-64.

\subsection flags_msc MSC flags
- All builds: <code>/DFOUNDATION_COMPILE=1 /DBUILD_<DEBUG|RELEASE|PROFILE|DEPLOY>=1 /Zi /W3 /WX /Oi /Oy- /MT /GS- /Gy- /GF- /Gm- /Qpar- /fp:fast /fp:except- /Zc:forScope /Zc:wchar_t /GR- /openmp-</code>
- Debug: <code>/Od</code>
- Release: <code>/Od</code>
- Profile: <code>/O2 /Ob2 /Ot /GT /GL</code>
- Deploy: <code>/Ox /Ob2 /Ot /GT /GL</code>

For x86 targets <code>/arch:SSE2</code> is used in all builds.

For x86-64 targets no additional flags are used.

\subsection flags_intel Intel flags

To be written...

\page test_page Running and verifying the test cases

The test cases is wrapped by a launcher application named test-all which will enumerate and launch each test executable
in sequence, aborting on failure. For iOS and Android all test cases are linked into the launcher executable to avoid
installing lots of small apps on the target device.

To install the test launcher on Android, use the Android SDK "adb" tool to install the test apk. For more information on running and debugging apps on emulators and/or devices refer to the Android SDK documentation.

\page tools_page Using the tools provided by the library

The library comes with a number of small tools to help with development of applications.

\section hashify
The hashify tool is used to generate headers with predefined hashed strings from definition text files. The library
itself has one such header in hashstrings.h which is generated from hashstrings.txt

To use the tool simply run it with the path to each definition file as argument, for example "hashify foundation/hashstrings.txt".
It will by default generate a file named like the definition file with the extension replaces with ".h". For more
options refer to the help information output by running hashify without any arguments.

The hashify tool will not touch the output file if it does not need updating, to avoid changing timestamps of the header
file and trigger rebuilds. This makes it suitable for automatic execution in build farms and similar environments.

<pre>hashify [--help] [--validate] [--generate-string \<string>] [\<filename> \<filename> ...] [--]
    Generated files have the same file name as the input file, with the extension replaced by .h
    Optional arguments:
      --validate                   Suppress output and only validate existing hashes
      --generate-string \<string>   Generate hash of the given string
      \<filename> \<filename> ...    Any number of input files
      --help                       Display the help message
      --                           Stop processing command line arguments</pre>

\section uuidgen
The uuidgen tool generates UUIDs using the uuid submodule in the library. It can generate version 1 (MAC address), 3 (MD5 hash)
and 4 (random) UUIDs. If you run the tool without any arguments it will generate a single version 4 (random) UUID to stdout.

<pre>uuidgen [--time n] [--random n] [--md5 \<namespace> \<name>] [--output \<filename>] [--help]
    If no arguments are given, one random-based UUID is output to stdout
    Optional arguments:
      --time n                     Generate n time-based UUIDs
      --random n                   Generate n random-based UUIDs
      --md5 \<namespace> \<name>     Generate a name-based UUID using the namespace UUID specified
                                   in \<namespace> and a name string specified in \<name>
      --output \<filename>          Output to \<filename> instead of stdout
      --binary                     Output binary data instead of ASCII (stdout is always ASCII)
      --lowercase                  Output UUID in lowercase hex
      --uppercase                  Output UUID in uppercase hex (default)
      --help                       Display the help message
      --                           Stop processing command line arguments</pre>

\section bin2hex
The bin2hex tool converts any given input file to a string based file with each input file byte output as a hex string value,
suitable for including as a data block in a C source file (format "0x23, 0x20, 0x46, 0x6f, ...")

<pre>bin2hex usage:
  bin2hex [--columns n] [--help] \<file> \<file> \<file> <...> [--]
    Required arguments:
      \<file>                       Input filename (any number of input files allowed). Output will be named "\<file>.hex"
    Optional arguments:
      --columns n                  Print n bytes in each column (default is 32)
      --help                       Display the help message
      --                           Stop processing command line arguments</pre>

\section plans Future plans
Currently there are no plans for extra tools, but if you have a suggestion or request feel free to leave us a comment on
our repository pages at https://github.com/mjansson/foundation_lib


\page overview_page Overview of the design principles and general api patterns

\section design_principles Design principles
This library provides a cross-platform foundation library in C providing basic support data types and
functions to write applications and games in a platform-independent fashion. It is written with the following API
design principles in mind:

<ul>
<li><b>Consistent</b>: All functions, parameters and types should follow a well defined pattern in order to make it easy to remember how function names are constructed and how to pass the expected parameters.
<li><b>Orthogonal</b>: A function should not have any side effects, and there should be only one way to perform an operation in the system.
<li><b>Specialized</b>: A function in an API should perform a single task. Functions should not do completely different unrelated tasks or change behaviour depending on the contents of the variables passed in.
<li><b>Compact</b>: The API needs to be compact, meaning the user can use it without using a manual. Note though that "compact" does not mean "small". A consistent naming scheme makes the API easier to use and remember.
<li><b>Contained</b>: Third party dependencies are kept to an absolute minimum and prefer to use primitive or well-defined data types.
</ul>

Each submodule is contained in one header/source file pair, with all function names beginning with the submodule name. For example, all calls related to bit buffers are contained in bitbuffer.h and have
the format "bitbuffer_<function>( bitbuffer_t*, ... )". If the function call requires a data object related to the submodule (in this case, bitbuffer_t) a pointer to the object is always the first function argument.

\section data_types Data types
The library uses standard C data types (char, unsigned int, ...) where exact data type size is not required, and standard integer types (int16_t, uint64_t) where explicit size is required. The library
extends these types with floating point data types:

<ul>
<li><i>float32_t</i>, <i>float64_t</i> for explicit size floating point data
<li><i>real</i> for a configurable generic floating point data type
</ul>

To set the <i>real</i> data type format set the #FOUNDATION_SIZE_REAL preprocessor macro to 4 or 8, or change the defined value in platform.h (default is 32 bit floating point values).

\section object_lifetime Object lifetime
Complex data types (objects) are handled in two ways. Either the caller have explicit lifetime control and accessed through raw pointers, or else has implicit control where the lifetime is handled by reference counting and accessed through object handles of type object_t (basically a 64-bit handle mapping into a lookup table).

Explicit allocations are always handled by function calls of the format <i>\<module>_t* \<module>_allocate(...)</i> to allocate the object and <i>void \<module>_deallocate(\<module>_t* ptr)</i> to deallocate it, for example md5_allocate and md5_deallocate in md5.h. The corresponding calls for initializing/finalizing a struct places on the stack is <i>void \<module>_initialize(\<module>_t* ptr)</i> and <i>void \<module>_finalize(\<module>_t* ptr)</i>. All objects that are initialized must be finalized in order to free any allocated resources correctly. Objects that are allocated on the heap with allocate/deallocate should not be initialized/finalized as this is done implicitly by the allocation and deallocation.

Implicit allocators are always handled by function calls of the format <i>object_t \<module>_create(...)</i> to allocate a new object, <i>\<module>_ref(object_t id)</i> to explicitly add a new reference to an existing object and <i>void \<module>_destroy(object_t id)</i> to release a reference to an existing object (and implicitly deallocate it when reference count reaches zero). Implicitly allocated objects does not need to be initialized/finalized.

Reference counted data types have a predefined maximum number of concurrently allocated objects defined in the #foundation_config_t object passed to #foundation_initialize, for example #foundation_config_t::library_max for dynamically loaded libraries.


\page features_page Details on specific submodules and features provided by the library

\section build_config Build configuration
Static build configuration is done in the build.h header by defining a set of preprocessor directives. All values can be set on compilation command line since the build declarations are checked for pre-existing definitions. It is, however, recommended to use the build header file to ensure the library and projects using the library have the same set of definitions.

Most important is the build type definition, #BUILD_DEBUG, #BUILD_RELEASE, #BUILD_PROFILE and #BUILD_DEPLOY. For a full list and documentation of the build configuration preprocessor definitions, check the documentation for the build.h header


\section runtime_config Runtime configuration
Most of the library configuration is done in runtime with a #foundation_config_t structure passed to #foundation_initialize. This config block controls sizes and limits of various subsystems and can be used to tweak the memory and resource usage of the library.


\section memory_management Memory management
Memory management is handled through a memory system implementation, which is basically three entry points for allocation, reallocation and deallocation. By default the foundation library provides a memory system built on the C library malloc/realloc/free family of functions, extended and wrapped to handle alignment requirements. When you initialize the foundation library you have to pass in a memory system implementation declaration through a #memory_system_t struct. To use the default malloc-based system, use #memory_system_malloc.

Memory allocations will belong to a memory context, which is usually a hash value of a module name (for example, #HASH_STREAM). This allows the memory tracker to place allocations in buckets to see how much memory each part/module of the software allocates at any given time. Memory context can be set explicitly with an argument to #memory_allocate or implicitly through the thread local memory context stack controlled with #memory_context_push and #memory_context_pop. The thread local context is used if you pass 0 as context to #memory_allocate and in #memory_reallocate when passed a null pointer.

Memory allocations can also give hint flags of the usage of the requested memory buffer. This allows the implementation to make optimizations and extra requirements during allocation. The memory hint flags are documented in MEMORY_[*] defines with the most common flags being #MEMORY_TEMPORARY and #MEMORY_ZERO_INITIALIZED for temporary (scope level) allocations and initialization to zero, respectively.

The memory management module also provides memory tracking if compiled with #BUILD_ENABLE_MEMORY_TRACKER set to 1, which tracks all allocations and deallocations and enable memory leak detection. A memory tracker is declared with the #memory_tracker_t struct, and the library provides a default local implementation in #memory_tracker_local. The maximum number of concurrent allocations the local memory tracker can keep track of is set with the #foundation_config_t::memory_tracker_max config directive passed to #foundation_initialize. A networked memory tracker will be provided in a network library, and further entry points to query the tracker during runtime will be added in a later release. Right now the tracker only prints detected leaks on application termination.

Finally there is a memory overwrite/underwrite guard functionality built in and enabled with the #BUILD_ENABLE_MEMORY_GUARD build.h preprocessor directive. This will incur a slight memory overhead on each allocation, adding a dead zone before and after each allocated memory block for detecting invalid memory writes outside the allocated area. This functionality is built on top of the memory system implementation which does not need to provide a guard implementation internally.


\section threading Threading
\subsection threads Threads
The threading module provides functionality to create and manage new execution threads and handle thread synchronization with mutexes and semaphores. A thread object represents a single execution thread for a specific function and cannot be reused for multiple execution threads of the same function. To have multiple execution threads of the same function, you must create multiple thread objects referring to the same function.

Thread execution is controlled with #thread_start and #thread_join. The #thread_join function will block until the execution thread has terminated and then free associated resources. You can use #thread_is_started to query if a thread has been started, and #thread_is_running to query if the thread is currently executing. A thread has a single result value of type void* which is the return value of the execution function. This value is returned by #thread_join when you join the thread.

Threads have a beacon for simple trigger behaviour between controller and executor. The controlling thread can use #thread_signal to signal the beacon, while the executing thread can use #thread_wait or #thread_try_wait to poll the signal state of the beacon. The common use case is to use the beacon to signal thread termination.

You can set thread affinity to specific CPU core(s) with the #thread_set_hardware function taking a bit mask of allowed cores, and use #thread_hardware to query which CPU core a thread is currently running on. To query how many CPU cores that are available use #system_hardware_threads.

The foundation library has the concept of a single main thread which is the application control thread. To set and query the main thread flag, use #thread_set_main and #thread_is_main. To further help debugging and thread identification, use #thread_set_name to set a human readable name for the thread which you will be able to see in the debugger.

Thread execution time slices can be given up to other execution threads with #thread_yield. For time controlled suspension of thread execution use #thread_sleep.

If you want to use the JNI to call into the JVM in a thread on the Android platform you must attach the thread using #thread_attach_jvm. Remember to call #thread_detach_jvm before terminating the thread to release the resources allocated by the attach call.

\subsection thread_synchonization Synchronization
The foundation library provides two mechanisms for thread synchronization, mutexes and semaphores. A mutex provides a lock for providing exclusive access to a resource or execution section as well as a signal/wait notification event, and a semaphore provides a thread safe access counter.

A mutex is allocated and destroyed with #mutex_allocate and #mutex_deallocate. The mutex name is for debugging purposes only (also used in profiling events), limited to 32 characters. #mutex_lock will lock the mutex to the calling thread and block until a lock can be obtained if another thread currently holds the lock. #mutex_unlock will unlock the mutex if the lock is held by the calling thread. To lock without blocking, use #mutex_try_lock, which will return false if the lock could not be obtained in the given time span. Mutexes are reentrant, meaning a thread can lock the same mutex with #mutex_lock multiple times without blocking, and the mutex is only unlocked when #mutex_unlock has been called by the thread the same number of times.

Mutex signals can be used to provide a simple way of combining a thread wait/lock scheme. A thread uses #mutex_wait to wait for a signal state sent by another thread with #mutex_signal, and if the thread was woken by a signal the mutex lock will be obtained and the #mutex_wait function returns true. Remember to call #mutex_unlock once lock is no longer needed.

Semaphores provide an interface to a counter which threads can use to have access to a resource limited to a specific number of concurrent uses (for example in a producer/consumer scheme). Mutexes can be considered a binary semaphore (maximum value of 1) with additional ownership tracking. You post to a semaphore to increase the counter (produce) and wait to decrease the counter (consume). If the current value is zero the wait will block until another thread has made a post to increase the value.

\subsection atomic_operations Atomic operations
Atomic operations are provides for 32-bit and 64-bit data types, along with an aliased interface for pointers which uses the appropriate 32/64-bit interface depending on architecture pointer size. There are also acquire/release memory fences for both signal and thread fencing.


\section debugging Debugging, profiling, logging and error handling

\subsection debugging_error_handling Error handling
Error handling is done with return values couple with thread local error state. Return values are either bool, integer or pointer values where false, negative values and null indicate an error condition respectively. The thread local error state is set with calls to either error log functions or error_report (see error.h file documentation). The error state of one thread does not affect the error state of any other thread. Reading the error state with a call to #error will reset the state to no error.

As an extra debugging help there is also a thread local error context stack providing debug messages and debug data for each layer of the current call stack using the error context functionality. The context frames are pushed and popped from the stack with calls to #error_context_push and #error_context_pop, read with #error_context and converted to descriptive string format with #error_context_buffer. If you need to have a local variable which only exists for error contexts, use #error_context_declare_local. Error context functionality is controlled by the #BUILD_ENABLE_ERROR_CONTEXT build control in build.h, and disabling it will reduce all error context calls and local variable declarations to void.

\subsection debugging_logging Logging
Logging output is provided in log.h through five different severity levels (debug, info, warning, error, panic, in increasing order of severity). Log messages are associated with a context (usually a hash of the corresponding module name string), and can be suppressed based on severity level per context using #log_set_suppress. If a context has no specific suppression level set, it will fall back on the default context (value 0) suppression.

Log messages are by default prefixed with additional debug data "[0:00:06.024] <513:0>" where the fields are time since startup, thread id and processor core, respectively. You can disable this prefix with #log_enable_prefix. Log messages are by default printed on stdout, which can be controlled with #log_enable_stdout. On Windows log messages are always output to the debugger with OutputDebugString.

To pipe log messages to other outputs use the log handler by implementing your own handler function and registering it using #log_set_handler. All final formatted log messages (after suppression and context filtering) will be passed to the handler.

Finally, the #BUILD_ENABLE_LOG controls if log functions are enabled. If the build control is disabled, all log function calls will be reduced to void. The debug functions #log_debug and #log_debugf have a separate build control #BUILD_ENABLE_DEBUG_LOG.

\subsection debugging_exceptions Exception handling
The foundation library provides structured exception handling based guards on Windows and signal based guards on posix compatible platforms. The guard acts as a proxy function call which will call the guarded function and catch any exceptional state. If an exception is caught, the state is written to a crash dump file and a handler is called with the dump information. The guard function itself returns with a specific value indicating a dump was generated. For more information on the exception handling check the exception.h documentation.

\subsection debugging_profiling Profiling
The profiling module provides an efficient function-level profiling system. It is not intended for fine grained instruction level optimization, but rather profiling the entire application on a function level scope. The module does not allocate any memory and is reentrant (thread safe). The basic use is to begin/end scope blocks around functions entry/exit with calls to #profile_begin_block and #profile_end_block. All string identifiers should be valid until the profile module flushes the data to the output function, and the easiest way to guarantee this is to use static C strings as identifiers (for example, <code>profile_begin_block("my block");</code>). If a block runs for a long time you should also call #profile_update_block to update information about which CPU core the thread is running on.

Data is collected on a frame-by-frame basis, make sure to call #profile_end_frame at the end of an application frame. All profile blocks must be closed by the time the frame is ended.

To enable the profile module you need to call #profile_enable. The module is initially disabled. On enble, the module starts a low-priority background thread which handles flushing the profile data to the output callback set by #profile_set_output. If no output callback is set, the profile data is silently discarded. You can control the rate at which the output flush thread wakes with #profile_set_output_wait as number of milliseconds to sleep between each flush. The smaller memory buffer you intialize the profiling module with, the more ofter the output thread needs to wake and flush in order to avoid data being lost from being out of memory. Default wait sleep is 100 milliseconds.

There are also functions for adding notices about mutex locks, waits and signals, as well as generic log messages.

All profiling module functions are enabled/disabled with the #BUILD_ENABLE_PROFILE build config directive in the build.h header. If you set #BUILD_ENABLE_PROFILE to 0, all profiling function calls will evaluate to void and not generate any code.

In the future we will provide a UI tool to analyze profiling data dumps and a network output client/server for collecting and analyzing profiling data remotely.

\section streams_files Streams and file access

\subsection streams Streams overview
Streams provide a generalized streaming I/O to various resources such as files, memory buffers, network sockets and pipes. The functions abstract away any platform specific implementations, byte order handling, binary/ascii modes and provides a single interface for I/O to any stream types. The functions in stream.h can be used to read/write to any stream type, and the stream specific implementations is handled through a "virtual table" of function pointers provided by the specific type.

Generally the generalized stream.h module functions is the only interface needed, but when initializing stack based or allocating heap stream objects of specific types (like #buffer_stream_initialize and #buffer_stream_allocate) you need to use the type specific initialization/allocation function and then the generalized stream functions to do any I/O.

Stream functions are not reentrant. If you need to do thread safe stream I/O you need to wrap it with a mutex lock or similar construct. A special case is the ring buffer stream, where one thread can write and another thread read concurrently.

\subsection stream_paths Paths and protocols
Streams are identified by a full path including a type "protocol". The full path format is "\<protocol>:\<path>". For example, a file stream full path is "file://tmp/appname/somefile.ext". The #stream_open function will correctly identify stream type from the protocol and initialize the correct data structure.

All paths use forward slashes "/" as separators. Absolute paths start with a root separator, "/absolute/path", and relative paths start without a separator, "relative/path". If the path is a full path including a protocol, the path is always considered to be absolute and should begin with a double forward slash, "//absolute/path". Thus together with the protocol specifier and the protocol separator, the full path becomes "protocol://absolute/path".

The path.h module provides utility functions to work with paths. All external paths of uncertain formats should be sanitized with #path_clean to make it adhere to the path format used in the library. All other stream and path functions assume the path is well formed and on the format specified above.

\subsection stream_byte_ordering Byte ordering
Streams with multi-byte data naturally have a byte order associated with the data. Since streams can wrap a network socket, the stream module provides automatic and transparent byte order handling based on the byte order of the stream and the byte order of the executing hardware. By default, streams local to the executing process such as memory buffer streams and pipes have the same byte order as the executing hardware. Other streams default to the byte order specified in the build configuration directive #BUILD_DEFAULT_STREAM_BYTEORDER (which defaults to little endian). You should set the byte order of a stream with #stream_set_byteorder if needed.

Once you have set the correct byte order on a stream all multi-byte read/write operations with automatically convert and I/O the data in the appropriate format. No further byte swapping is needed in the application code.

\subsection stream_traits Stream traits and modes
Streams have a number of traits that determine what kind of features and guaranteed the stream type implementation provides. This allows the stream interface to abstract across UDP network streams and other non-reliable resources.

The stream traits are inorder, reliable, sequential, binary, and swapped. The traits can be queried with stream_is_<trait> family of functions. Only binary and byte order traits can be changed explicitly, all other traits are inherent to the stream type. Operations unsupported by the stream trait set will silently be ignored (like seeking backwards on a sequential stream). The traits meanings:
<ul>
<li><b>in order:</b> The data written to the stream is guaranteed to be read back in the same order
<li><b>reliable:</b> The data written to the stream is guaranteed to be readable
<li><b>sequential:</b> The data can only be written to and read from the stream in sequence. No random access is available, and only forward seeking from the current position is supported. Stream size is generally unavailable for sequential streams.
<li><b>binary:</b> Data is written to and read from the stream in binary format. If the binary trait is not set, data will be converted to/from ASCII strings before write or after read operations.
<li><b>swap:</b> Multi-byte data byte order will be swapped before write or after read operations (only for binary streams).
</ul>

Streams are opened with a specific open mode, see STREAM_[*] mode/flag definitions with #STREAM_IN and #STREAM_OUT being the main I/O modes. Some streams will enforce specific modes (like read-only or write-only). Operations unsupported by the current mode will be silently ignored (like reading from a write-only mode stream). If the requested mode is unavailable for a given stream implementation or trait set it will be silently ignored.

\subsection stream_special Special streams
The standard library stdout, stderr and stdin files are wrapped in special streams available through the #stream_open_stdout, #stream_open_stderr and #stream_open_stdin functions. Stdout and stderr are write-only, while stdin is read-only.

\section data_structures Data structures
The library provides a number of basic container data types.

\subsection data_arrays Arrays
The array.h module is a simple resizable array implemented as a set of macros operating directly on the argument pointer. Memory allocation is done in chunks reserving additional memory when the current capacity is used up. Arrays are never implicitly resized to a smaller capacity in order to avoid extra allocations and memory copy operations. By default the array does not preserve order but rather use swap-with-last to erase elements, and operations are not ranged checked. The <code>*_ordered</code> functions provide order preserving operations and <code>*_safe</code> functions provide range checking. Arrays are not thread safe, you need to use a mutex or similar construct to wrap operations for thread safety.

\subsection data_hashmap Hash map
The hashmap.h module is a resizable hash map providing mapping between hash value keys and pointer data. The hash map will have a fixed number of buckets set at initialization time, but each bucket will grow to accomodate storage need by utilizing the array module. Hash maps are not thread safe, you need to use a mutex or similar construct to wrap operations for thread safety.

\subsection data_hashtable Hash table
The hashtable.h module is a fixed size hash table providing a thread safe atomic hash table mapping hash value keys to 32 or 64 bit value data. All operations are thread safe, which also limits the functionality to storing a 32 or 64 bit data element per hash key. Also, keys can not be fully erased once stored, only reset to hold value zero as an indicator of the key being erased. Therefor the size of the hash table must be initialized to the maximum number of unique keys to be stored over the lifetime of the hash table.

\section strings String handling and unicode support
The string.h module provides string utility functions focusing on features, utf-8 support and ease of use rather than performance and minimal footprint. If you are building an application that relies heavily on string processing, you would be better off looking at additional libraries.

\subsection string_utf8 UTF-8 and wide character strings
All strings are considered to be on UTF-8 format. However, most length, offset and other index type variables and arguments are considered to be representing bytes, not compound UTF glyphs consisting of multiple UTF-8 byte sequences. This means functions like #string_length returns the length of the string buffer in bytes (memory footprint). To get the number of actual UTF glyphs in a string and the glyphs themselves, use #string_glyphs and #string_glyph.

There are utility functions to convert to and from wide character strings, UTF-16 strings and UTF-32 strings. The API is designed around performing all operations in UTF-8 format and only using wide string formats in external APIs.

\subsection string_handling String functions
The module provides functions to allocate, initialize, format and deallocate strings both allocating new memory buffers as well as working with existing pre-allocated buffers. Unless otherwise noted in the API documentation, all functions allow null pointers to be passed as arguments if the corresponding length and/or capacity argument are also zero. It is an error to pass a null pointer with a non-zero length/capacity argument.

Strings are declared with a pointer to a memory block and the length of the string. Zero termination is generally NOT enforced. Functions that allocate or modify strings always return zero-terminated strings. Functions that find substrings and return const string arguments does not modify or allocate memory, and returns substrings which are NOT zero terminated. Check the documentation for each function for further details regarding zero termination state.

All functions in the library taking string arguments as (pointer, length) tuples respect given lengths and does not require zero termination. This design minimized calls to find string lengths and minimizes additional memory allocations to store zero terminated substrings by allowing substrings to be declared as a (pointer, length) tuple into the original string memory buffer.

In general, all arguments of type <code>char*</code> are expected to be strings allocated by the string module or #memory_allocate. Arguments of type <code>const char*</code> can be any string, including static compile time strings and stack based data. String arguments will never be modified or reallocated unless explicitly stated in the function API documentation (generally only allocate and resize functions). For more details, check the API documentation for each function.

The #string_find find family of functions takes offset arguments which are byte offsets into the given string argument. Invalid offsets are denoted by the #STRING_NPOS constant (-1). If reverse find functions (last of and rfind), #STRING_NPOS will mean searching from the end of the string. Apart from the special #STRING_NPOS offset, all other offset arguments are expected to be valid in [0..length) interval.

\subsection string_regex Regular expressions
Apart from the simple wildcard #string_match_pattern function, the regex.h provides a limited regular expression module with a subset of perl regex features. The regex module supports the following features:
<pre>    ^        Match beginning of string
    $        Match end of string
    .        Match one character
    ()       Group and capture substring
    []       Match any character from the grouped set
    [^]      Match any character but ones from the grouped set
    \\s       Match whitespace
    \\S       Match non-whitespace
    \\d       Match decimal digits
    \\D       Match non-digits
    \\n       Match newline
    \\r       Match carriage return
    +        Match one or more times (longest possible match)
    +?       Match one or more times (shortest possible match)
    *        Match zero or more times (longest possible match)
    *?       Match zero or more times (shortest possible match)
    ?        Match zero or once
    \\XX      Match byte with hex value 0xXX
    \\meta    Match one of the meta characters ^$()[].*+?|\
</pre>
Substring capturing is optional, and if performed it will capture start pointers and lengths of matched substrings and will not allocate any additional memory.

\page using_page Using the foundation library in a project

\section project_setup Project setup

\subsection project_scons Ninja
Use the provided build generator in example/build/ninja and modify the configuration script in example/configure.py to suit your needs. The local variables module, sources, libs, includepaths and libpaths control the basic setup of the project.

<ul>
<li>project - Name of the project (and the executable). By default this is also the subdirectory name holding the sources.
<li>sources - Source files inside the module subdirectory
<li>libs - External libraries to link with
<li>includepaths - External include paths
<li>libpaths - External library paths
</ul>

For further documentation on how to setup a Ninja build check out the \ref ninja section.

\subsection project_visual_studio Visual Studio

\subsection project_xcode XCode


\section template_app Template application

\subsection template_initialize Initialization
<code>int main_initialize(void)</code><br>
The initialization entry point of the application. It is expected to call #foundation_initialize and perform any other initialization in this function. It should return 0 if successful, or a negative value to indicate error in which case the application will terminate without running and use the returned value as exit code.

The example application uses default values for all foundation configuration controls by doing<br><code>foundation_config_t config;<br>memset(&config, 0, sizeof(config));</code><br>For more information about the configuration controls, read the #foundation_config_t documentation.

It also defines the application data with<br><code>application_t application;<br>
memset(&application, 0, sizeof(application));<br>
application.name = string_const(STRING_CONST("Foundation example application"));<br>
application.short_name = string_const(STRING_CONST("example"));<br>
application.company = string_const(STRING_CONST("My Company"));<br>
application.version = foundation_version();<br>
application.flags = APPLICATION_UTILITY;<br>
application.exception_handler = example_exception_handler;</code><br>
Note that the string data passed in this structure must be constants and valid for the lifetime of the application. More information available in the #application_t documentation.

The example application also sets a default log suppression level and initializes the memory tracker. Finally it locates the base directory of the application and sets this as the current working directory.

\subsection template_finalize Finalization
<code>void main_finalize(void)</code><br>
The finalization entry point of the application. It is expected to do any custom finalization and cleanup and finally call #foundation_finalize to terminate the library operations.

\subsection template_execution Execution
<code>int main_run(void*)</code><br>
Execution entry point of the application. Called to execute the application once the initialization has completed successfully. The return value from main_run is used as the process exit code. This is where the application logic should be implemented.

\subsection template_environment Environment

\subsection template_system System

\subsection template_platform Platform specifics
Android - ...

iOS - ...

*/
